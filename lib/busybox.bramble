load("github.com/maxmcd/bramble/lib/std")

"""busybox"""


def busybox():
    # download the executable, this is the only way you are allowed
    # to use the network during builds
    download = std.fetch_url("https://brmbl.s3.amazonaws.com/busybox-x86_64.tar.gz")

    # we pass the build_busybox callback here which is used to build this derivation
    return derivation(
        name="busybox", builder=_build_busybox, env=dict(download=download),
    )


def touch_file():
    bb = busybox()
    s = os.session()
    s.setenv("PATH", bb.out + "/bin")
    std.exec(s, "touch goo")


def _build_busybox(s, outputs):
    os.mkdir(outputs["out"] + "/bin")  # using the builtin os module

    # move the busybox executable into the output for this build

    std.exec(
        s,
        "$download/busybox-x86_64",
        "cp",
        "$download/busybox-x86_64",
        "$out/bin/busybox",
    )

    # extract the available commands from the busybox help text
    commands = []
    commands_started = False
    for line in std.exec(s, "$out/bin/busybox").output:
        if commands_started:
            for name in line.strip().split(","):
                name = name.strip()
                if name:
                    commands.append(name)
        if "Currently defined functions" in line:  # the builtin os module
            commands_started = True

    # cd into the output directory so that symlinks are relative
    s.cd(s.expand("$out/bin"))
    std.exec(s, "./busybox ln -s busybox ln")

    # link each command so that we can use all the available busybox commands
    for c in commands:
        if c != "ln":
            std.exec(s, "./ln -s busybox %s" % c)


def run_busybox():
    bb = busybox()

    # whoami is now available to run
    print(bb.out)
    print(os.cmd("whoami", clear_env=True, env={"PATH": bb.out + "/bin"}).output())
